## 内存管理

### 地址空间

- 空闲内存管理
  - 管理方法：
    - 位图法
    - 链表法
  - 空闲内存分配算法：
    - 首次适配
    - 下次适配：记录上一次空闲的位置
    - 最佳适配

### 虚拟内存

- 虚拟内存（virtual memory）是什么？（What）

  > 从概念上可以将虚拟内存看成是存储在**磁盘**上的N个连续的字节数组

  <img src="https://i.loli.net/2021/07/14/FVg2oY8Ahjfleqt.png" alt="image-20210714170655407" style="zoom:67%;" />

- 虚拟内存的思想：

  > 每个程序拥有自己的**地址空间**，这个空间被分成多个块，每一块叫做Page，而Page是一块连续的内存区域

- 虚拟内存的三大作用（Why）

  - 作为缓存的工具

    - 虚拟页面的集合：

      - 未分配的：VM系统还未分配页，因此没有数据与未分配的块有关联，**不占用磁盘空间**
      - 缓存的：该页已经由VM系统分配，并且缓存到主存（DRAM）中
      - 未缓存的：该页已经由VM系统分配，但还未缓存到主存中（在磁盘里）

    - 页表（Page Table）：用于虚拟**页**和物理**页**之间的映射

      > Notes：注意页表并不是执行**地址翻译**的操作，地址翻译由MMU执行，然后得到对应的物理地址，定位到页表中的表项

      <img src="https://i.loli.net/2021/07/14/oUyxtbIgV5s8fui.png" alt="image-20210714172048288" style="zoom:67%;" />

  - 作为内存管理的工具

  - 作为内存保护的工具
  
- 虚拟内存的实现（How）

  - 分页
  - 页表
  - 加速地址映射过程
  - 针对大内存的页表

- 页面置换算法

  - 最优置换算法（无法实现）

  - 最近未使用页面置换算法（Not Recently Used）

    > 为每个页面设置两个状态位：R位和W位。时钟中断会定时将R位清零（不清除W是因为写会磁盘会用到该位）
    >
    > 发生缺页中断时，OS检查所有的页面并根据它们当前的R和W的值，把它们分成四类：
    >
    > - 第0类：没有被访问，没有被修改
    > - 第1类：没有被访问，被修改
    > - 第2类：被访问，没有被修改
    > - 第3类：被访问，被修改
    >
    > 随机从最小的类编号页面集合中选择一个页面进行淘汰

  - 先进先出

  - 二次机会页面置换（减少先进先出误杀页面的情况）

    > 检查最老页面的R位，如果R为0，直接换出或写回磁盘（W为1）；否则将该页面放入链表尾部，R位清零（像新加入页面一样）

  - 时钟页面置换算法

    > 对二次机会算法的一个改进，将单链表换成循环链表

  - **最近最少使用（LRU）**

  - Aging算法（软件模拟LRU）：

    > 每个时钟滴答进行一次计数器右移，并将访问位加在高位

    ![image-20210820203058970](https://i.loli.net/2021/08/20/7I5hkiH3Xmq1C4r.png)

  - 工作集页面置换算法

    > （What）一个进程正在使用的页面叫做工作集。
    >
    > 工作集模型：跟踪进程的工作集合，确保进程运行以前它的工作集已经存在于内存中。
    >
    > （Why）局部性原理，以及减少缺页中断
    >
    > （How）
    >
    > $w(k, t)$表示$t$时刻的工作集合（最近$k$​次访问），如果以访问次数来计算工作集，则需要额外的寄存器，维护这样的寄存器并在缺页中断时处理它会导致较大的开销。因此，实际也是用近似方法来实现：
    >
    > 可以把工作集定义为**过去$t$​​时间内的访问页面集合**
    >
    > ![image-20210820210642344](https://i.loli.net/2021/08/20/kqyCsSOf1lKrETD.png)
    >
    > 记住**最小上次使用时间**的目的是当有多个R = 0且生存时间小于$t$​的页面时，置换时间最近的那个

  - 工作集时钟页面置换算法：

    > （What）时钟算法与工作集算法的集合
    >
    > （Why）工作集页面置换算法每次都需要从头扫描，才能确定被淘汰的页面，因此比较耗时。也同时钟算法一样，避免页面移动
    >
    > ![image-20210820212045299](https://i.loli.net/2021/08/20/43iDtrL85d1uMGH.png)
    >
    > （How）Notes：如果页面被修改过（W位为1），不能立即申请页框，避免由于调度写磁盘操作引起的进程切换，指针应继续往前走

  > 页面置换算法总结：
  >
  > ![image-20210820214158154](https://i.loli.net/2021/08/20/5dgEtXOZGSiHeDN.png)

- 分页系统中的设计问题

  - 共享页面

    > 不同进程间共享I空间（Instruction），拥有自己的D空间（Data）。
    >
    > 父子进程间是**写时复制**

  - 共享库（动态链接）
  
- Linux中虚拟内存的组织

  ![](https://i.loli.net/2021/10/14/rMvpKYWJyE9ufB1.png)

  - `task_struct`：包含内核运行该进程所需要的所有信息（PC，PID，可执行文件的名字，指向用户栈的指针等），其中有个`mm`指向`mm_struct`，它描述虚拟内存的当前状态
  - `mm_struct`：包含`pgd`（一级页表的基址）和一个指向`vm_area_struct`的`mmap`指针
  - 每个`vm_area_struct`描述当前地址空间中的一个区域

  > 用户空间调用`mmap`就是创建一个`vm_area_struct`

